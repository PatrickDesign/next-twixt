{"ast":null,"code":"\"use strict\";\n\nvar _Map = require(\"@babel/runtime-corejs2/core-js/map\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass UrlNode {\n  constructor() {\n    this.placeholder = true;\n    this.children = new _Map();\n    this.slugName = null;\n    this.restSlugName = null;\n  }\n\n  insert(urlPath) {\n    this._insert(urlPath.split('/').filter(Boolean), [], false);\n  }\n\n  smoosh() {\n    return this._smoosh();\n  }\n\n  _smoosh(prefix = '/') {\n    const childrenPaths = [...this.children.keys()].sort();\n\n    if (this.slugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n    }\n\n    if (this.restSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n    }\n\n    const routes = childrenPaths.map(c => this.children.get(c)._smoosh(`${prefix}${c}/`)).reduce((prev, curr) => [...prev, ...curr], []);\n\n    if (this.slugName !== null) {\n      routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n    }\n\n    if (!this.placeholder) {\n      routes.unshift(prefix === '/' ? '/' : prefix.slice(0, -1));\n    }\n\n    if (this.restSlugName !== null) {\n      routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));\n    }\n\n    return routes;\n  }\n\n  _insert(urlPaths, slugNames, isCatchAll) {\n    if (urlPaths.length === 0) {\n      this.placeholder = false;\n      return;\n    }\n\n    if (isCatchAll) {\n      throw new Error(`Catch-all must be the last part of the URL.`);\n    } // The next segment in the urlPaths list\n\n\n    let nextSegment = urlPaths[0]; // Check if the segment matches `[something]`\n\n    if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n      // Strip `[` and `]`, leaving only `something`\n      let segmentName = nextSegment.slice(1, -1);\n\n      if (segmentName.startsWith('...')) {\n        segmentName = segmentName.substring(3);\n        isCatchAll = true;\n      }\n\n      if (segmentName.startsWith('.')) {\n        throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n      }\n\n      function handleSlug(previousSlug, nextSlug) {\n        if (previousSlug !== null) {\n          // If the specific segment already has a slug but the slug is not `something`\n          // This prevents collisions like:\n          // pages/[post]/index.js\n          // pages/[id]/index.js\n          // Because currently multiple dynamic params on the same segment level are not supported\n          if (previousSlug !== nextSlug) {\n            // TODO: This error seems to be confusing for users, needs an err.sh link, the description can be based on above comment.\n            throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n          }\n        }\n\n        if (slugNames.indexOf(nextSlug) !== -1) {\n          throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n        }\n\n        slugNames.push(nextSlug);\n      }\n\n      if (isCatchAll) {\n        handleSlug(this.restSlugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n        this.restSlugName = segmentName; // nextSegment is overwritten to [] so that it can later be sorted specifically\n\n        nextSegment = '[...]';\n      } else {\n        handleSlug(this.slugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n        this.slugName = segmentName; // nextSegment is overwritten to [] so that it can later be sorted specifically\n\n        nextSegment = '[]';\n      }\n    } // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n\n\n    if (!this.children.has(nextSegment)) {\n      this.children.set(nextSegment, new UrlNode());\n    }\n\n    this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n  }\n\n}\n\nfunction getSortedRoutes(normalizedPages) {\n  // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n  // Only 1 dynamic segment per nesting level\n  // So in the case that is test/integration/dynamic-routing it'll be this:\n  // pages/[post]/comments.js\n  // pages/blog/[post]/comment/[id].js\n  // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n  // So in this case `UrlNode` created here has `this.slugName === 'post'`\n  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n  // Instead what has to be passed through is the upwards path's dynamic names\n  const root = new UrlNode(); // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n\n  normalizedPages.forEach(pagePath => root.insert(pagePath)); // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n\n  return root.smoosh();\n}\n\nexports.getSortedRoutes = getSortedRoutes;","map":null,"metadata":{},"sourceType":"script"}